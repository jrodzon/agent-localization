
\chapter{Implementation} \label{chap:implementation}

\section{Working environment}

This section describes the working environment from both, software and hardware perspectives.

\subsection{Technology stack}

The following technology stack was used:
\begin{itemize}
  \item \textbf{Ubuntu} - Linux operating system widely used in the computer vision community.
  Multiple versions were used: \texttt{16.04}, \texttt{20.04}, \texttt{22.04}, \texttt{24.04}. \cite{ubuntu-site}
  \item \textbf{Conda} - Package manager for isolated environments for each of the used projects. \cite{conda-documentation}
  \item \textbf{Python} - Main programming language for writing code and conducting experiments.
  Multiple versions were used: \texttt{3.7.16}, \texttt{3.9.10}, \texttt{3.9.18}. \cite{python}
  \item \textbf{CUDA} - A development environment for GPU-accelerated applications.
  Multiple versions were used: \texttt{11.6.1}, \texttt{11.7.1} \cite{cuda-toolkit}
  \item \textbf{PyTorch} - A machine learning framework with CUDA integration.
  Multiple versions were used: \texttt{0.4.1}, \texttt{1.10.1}, \texttt{1.13.1} \cite{pytorch}
\end{itemize}

\subsection{Workstation parameters}

The experiments were prepared and conducted on a personal computer with the following specifications:
\begin{itemize}
  \item CPU: Intel(R) Core(TM) i5-10400F CPU @ 2.90GHz \cite{intel-core-cpu}
  \item GPU: NVIDIA GeForce RTX 4060 \cite{nvidia-gpu}
  \item Hard Drive: Samsung SSD 990 PRO 2TB \cite{samsung-disc}
\end{itemize}

\section{Preparing test dataset}

To evaluate the algorithms' real-life usefulness, I prepared a small test dataset of photos.
The dataset contains a variety of indoor scenes with plenty of tricky floor layouts,
including glass walls, windows, and mirrors.
Additionally, there are several photos of the outskirts of the building
to evaluate the algorithms' coping with the outdoor environment within the building's proximity.
Each scene was shot in two different lighting conditions - day and night.
Thus, the dataset is capable of testing the effect of illumination on segmentation quality.

\par

The photos were taken with the rear camera of the \texttt{Samsung Galaxy A54 5G} phone
with the model name \texttt{SM-A546B/DS}.
The building that served as a source of the indoor and outdoor scenes
is the main building of the AGH faculty of Computer Science - D17.

\subsection{Calculating Camera Matrix}

Many plane segmentation algorithms require camera intrinsic parameters
to correctly perform plane segmentation and depth prediction.
In this thesis, PlaneRCNN required the following camera matrix:
\begin{equation} \label{eq:camera-matrix}
	C = \begin{bmatrix}
		f_x &   0 & c_x & \\
		  0 & f_y & c_y & \\
		  0 &   0 &   1 & \\
	\end{bmatrix}
\end{equation}

where:
\begin{itemize}
\item $f_x$ is the focal length in pixels on x-axis
\item $f_y$ is the focal length in pixels on y-axis
\item $c_x$ is the principal point x-axis coordinate in pixels
\item $c_y$ is the principal point y-axis coordinate in pixels
\end{itemize}

Based on the pinhole camera model from Figure~\ref{figure:Pinhole-Camera-Model}
from Section~\ref{subsection:rgb-to-pc-mapping},
these are the mathematical recipes for all the necessary parameters:
\begin{equation} \label{eq:camera-intrinsic-parameters}
\begin{cases}
  f_x = \frac{\frac{1}{2}R_h}{\tan(\frac{1}{2}FoV_h)} \\
  f_y = \frac{\frac{1}{2}R_v}{\tan(\frac{1}{2}FoV_v)} \\
  c_x = \frac{1}{2}R_h \\
  c_y = \frac{1}{2}R_v
\end{cases}
\end{equation}

where:
\begin{itemize}
  \item $R_h$ is the camera horizontal resolution in pixels
  \item $R_v$ is the camera vertical resolution in pixels
  \item $FoV_h$ is the camera horizontal field of view in degrees
  \item $FoV_v$ is the camera vertical field of view in degrees
\end{itemize}

The image resolution is \texttt{4080x3060}, so $R_h = 4080$ and $R_v = 3060$.
From the publicly available documentation about the rear camera in the phone,
I got the horizontal and vertical field of view (FoV). \cite{camera-fv-5-samsung-a54}
Thus, we get the respective values for $FoV_h = \ang{72.7}$ and $FoV_v = \ang{57.8}$.
Applying these values to the Equation~\ref{eq:camera-intrinsic-parameters} gives the following result:
\begin{equation} \label{eq:camera-intrinsic-parameters-solved}
\begin{cases}
  f_x = 2772.05 \approx 2772 \\
  f_y = 2771.59 \approx 2772 \\
  c_x = 2040 \\
  c_y = 1530
\end{cases}
\end{equation}

\section{Setting-up the environment}

The first step in using every repository is setting the working environment up.
Nowadays, almost every project using some form of artificial intelligence is Python-oriented.
This is especially true for algorithms that incorporate some forms of neural networks.
This fact is not coincidental - the Python environment is rich in multiple sophisticated libraries.
These libraries provide means for many highly complicated tasks, such as matrix operations,
which are essential for any neural network manipulations.
Additionally, training a neural network is a process, which requires huge amounts of computation.
Because of that, graphic cards (Graphic Processing Unit - GPU)
are entangled to do most of the demanding calculations.
GPUs are normally optimized for graphic computations, 
o there are separate dedicated drivers that transform a classic GPU
into a General Purpose Graphic Processing Unit (GPGPU),
which is tuned for mathematical calculations.

\par

Ultimately, we end up with a tremendously complicated environment with
dedicated graphic drivers, python libraries, system libraries, etc.
Each of these components adds an additional layer of complexity.
Taking into consideration the environment specification,
getting a state-of-the-art neural network project going may be a highly challenging and time-consuming task.

\subsection{PlaneRCNN} \label{subsec:planercnn}

I have started my work with an attempt to set up the PlaneRCNN repository. \cite{planercnn-repository}
At first glance, everything looks good - there is an installation instruction together with a `requirements.txt` file.
All the installation went smoothly, but when I tried to run an example evaluation:
\begin{lstlisting}[language=bash,basicstyle=\small]
    $ python evaluate.py --methods=f --suffix=warping_refine --dataset=inference --customDataFolder=example_images
\end{lstlisting}
The following exception occurred:
\begin{lstlisting}[language=bash,basicstyle=\tiny]
    Traceback (most recent call last):
    File "evaluate.py", line 20, in <module>
      from models.model import *
    File "/home/agent/Masters/Repos/planercnn/models/model.py", line 23, in <module>
      from nms.nms_wrapper import nms
    File "/home/agent/Masters/Repos/planercnn/nms/nms_wrapper.py", line 11, in <module>
      from nms.pth_nms import pth_nms
    File "/home/agent/Masters/Repos/planercnn/nms/pth_nms.py", line 2, in <module>
      from ._ext import nms
    File "/home/agent/Masters/Repos/planercnn/nms/_ext/nms/__init__.py", line 3, in <module>
      from ._nms import lib as _lib, ffi as _ffi
  ImportError: /home/agent/Masters/Repos/planercnn/nms/_ext/nms/_nms.so: undefined symbol: __cudaRegisterFatBinaryEnd
\end{lstlisting}

After some thorough investigation,
I discovered that the PyTorch \cite{pytorch} in version \texttt{0.4.1}
supports only old CUDA (Compute Unified Device Architecture \cite{cuda-toolkit}) versions,
which are incompatible with modern GPUs.

\par

Based on this knowledge, I tried to bump the PyTorch version to at least \texttt{1.10},
which offers support with some of the latest CUDA releases.
Then I encountered another obstacle - there are two custom CUDA modules written in C \cite{c-language}:
\begin{itemize}
\item \texttt{nms} - implementation of Non-Maximum Suppression algorithm
\item \texttt{roi\_align} - implementation of RoIAlign algorithm proposed by He et al. \cite{inproceedingsMaskRCNN}
\end{itemize}

Unfortunately, PyTorch from version \texttt{1.0.0} removed support for \texttt{C} modules
and left only the \texttt{C++} \cite{cpp-language} option.
Since these custom modules needed to be rewritten anyway, after some additional research,
I was able to get rid of them completely,
thanks to the publicly available replacement by WeihongPan \cite{planercnn-repository-weihong-pan-fork}.
Thanks to this, the process of setting up the PlaneRCNN environment was simplified.

We can get rid of both custom modules:
\begin{itemize}
\item \texttt{nms}
PyTorch library, in higher versions, provides the Non-Maximum Suppression algorithm,
so a version update is enough in this case.
\item \texttt{roi\_align}
Implementation of the RoIAlign algorithm is now available as a separate package \cite{roialign-package},
so it is installed instead of using the \texttt{roi\_align} custom module.
\end{itemize}

\par

WeihongPan also published his own method of setting up the PlaneRCNN environment,
but it also failed on the package incompatibilities.

Package requirements installation:
\begin{lstlisting}[language=bash]
$ pip install -r requirements.txt
\end{lstlisting}
Failed with the following error:
\begin{lstlisting}[language=bash]
Collecting cffi==1.15.0 (from -r requirements.txt (line 10))
  Using cached cffi-1.15.0-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.whl.metadata (1.2 kB)
Collecting numpy==1.19.2 (from -r requirements.txt (line 11))
  Using cached numpy-1.19.2.zip (7.3 MB)
  Installing build dependencies ... done
  Getting requirements to build wheel ... done
  Preparing metadata (pyproject.toml) ... error
  error: subprocess-exited-with-error
  RuntimeError: Running cythonize failed!
\end{lstlisting}
which suggests package incompatibilities.

\par

Based on this knowledge, I decided to select my own set of compatible libraries
and ship them as a Conda \cite{conda-documentation} environment definition.
As a result of this operation, the \texttt{environment.yml} file was created:
\begin{lstlisting}[style=yaml]
name: planercnn_pytorch_1_13_cuda_11_7
channels:
  - pytorch
  - conda-forge
  - nvidia
  - defaults
dependencies:
  - cffi=1.15.1
  - matplotlib=3.8.4              # required by RoIAlign test.sh https://github.com/longcw/RoIAlign.pytorch
  - mkl=2024.0                    # due to a pytorch bug https://github.com/pytorch/pytorch/issues/123097
  - numpy=1.21.2
  - opencv=4.5.5
  - pytorch::pytorch=1.13.1
  - scikit-image=0.19.3
  - pytorch::torchvision=0.14.1   # required by RoIAlign test.sh https://github.com/longcw/RoIAlign.pytorch
  - tqdm=4.66.5
prefix: $HOME/.conda/envs/planercnn_pytorch_1_13_cuda_11_7
\end{lstlisting}

Additionally, I have prepared a convenience script for RoIAlign installation:
\begin{lstlisting}[language=bash]
#!/bin/bash

WORKDIR="roi_align_installation"
GITHUB_URL="https://github.com/longcw/RoIAlign.pytorch"

mkdir $WORKDIR
git clone $GITHUB_URL $WORKDIR
cd $WORKDIR

python setup.py install
./test.sh

cd ..
rm -rf $WORKDIR
\end{lstlisting}

Due to this, I was able to add an instruction, which sets up the PlaneRCNN with just a few simple steps:
\begin{lstlisting}[language=bash]
$ conda env create -f environment.yml
$ conda activate planercnn_pytorch_1_13_cuda_11_7
$ conda install h5py=3.7.0
$ ./install_roi_align.sh
\end{lstlisting}

\subsection{PlaneRecNet}

With PlaneRecNet \cite{xie2021planerecnet},
there was a similar situation as with the PlaneRCNN from Section~\ref{subsec:planercnn}.
There is the whole conda environment exported to the file \texttt{environment.yml}.
So, in theory, anyone should be able to get the environment running with a simple command:
\begin{lstlisting}[language=bash]
$ conda env create -f environment.yml
\end{lstlisting}

Unfortunately, I encountered the following error:
\begin{lstlisting}[language=bash]
Solving environment: failed

LibMambaUnsatisfiableError: Encountered problems while solving:
  - package libopencv-4.5.3-py39h70bf20d_1 requires ffmpeg >=4.3.2,<4.4.0a0, but none of the providers can be installed

Could not solve for environment specs
The following packages are incompatible
  - ffmpeg ==4.4.0 h6987444_5 is requested and can be installed;
  - libopencv ==4.5.3 py39h70bf20d_1 is not installable because it requires
      - ffmpeg >=4.3.2,<4.4.0a0 , which conflicts with any installable versions previously reported.
\end{lstlisting}

In other words, some of the libraries are incompatible.
To resolve the problem, I tried manipulating versions of the conflicting libraries.
But as a result, I always received even more errors.

\par

I decided to build a compatible set of libraries from scratch as a conda environment definition.
I selected the same PyTorch and CUDA versions as in Section~\ref{subsec:planercnn},
and then, fit the rest of the dependencies.
As a result, the following \texttt{environment.yml} file was created:
\begin{lstlisting}[style=yaml]
name: PlaneRecNet
channels:
  - pytorch
  - conda-forge
  - nvidia
  - defaults
dependencies:
  - cffi=1.15.1
  - cuda-toolkit=11.7
  - numpy=1.21.2
  - opencv=4.5.3
  - pytorch::pytorch=1.13.1
  - scipy=1.7.1
  - pytorch::torchaudio=0.13.1
  - pytorch::torchvision=0.14.1
prefix: $HOME/.conda/envs/PlaneRecNet  
\end{lstlisting}

Finally, anyone can set up their working environment for PlaneRecNet with just one simple command:
\begin{lstlisting}[language=bash]
$ conda env create -f environment.yml
\end{lstlisting}
